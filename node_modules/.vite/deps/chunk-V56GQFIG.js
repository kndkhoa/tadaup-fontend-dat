import {
  __esm,
  __export
} from "./chunk-SEVZ5PBP.js";

// node_modules/@motionone/types/dist/MotionValue.es.js
var MotionValue;
var init_MotionValue_es = __esm({
  "node_modules/@motionone/types/dist/MotionValue.es.js"() {
    MotionValue = class {
      setAnimation(animation) {
        this.animation = animation;
        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => {
        });
      }
      clearAnimation() {
        this.animation = this.generator = void 0;
      }
    };
  }
});

// node_modules/@motionone/types/dist/index.es.js
var init_index_es = __esm({
  "node_modules/@motionone/types/dist/index.es.js"() {
    init_MotionValue_es();
  }
});

// node_modules/@motionone/utils/dist/is-function.es.js
var isFunction;
var init_is_function_es = __esm({
  "node_modules/@motionone/utils/dist/is-function.es.js"() {
    isFunction = (value) => typeof value === "function";
  }
});

// node_modules/@motionone/utils/dist/array.es.js
function addUniqueItem(array, item) {
  array.indexOf(item) === -1 && array.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}
var init_array_es = __esm({
  "node_modules/@motionone/utils/dist/array.es.js"() {
  }
});

// node_modules/@motionone/utils/dist/clamp.es.js
var clamp;
var init_clamp_es = __esm({
  "node_modules/@motionone/utils/dist/clamp.es.js"() {
    clamp = (min, max, v) => Math.min(Math.max(v, min), max);
  }
});

// node_modules/@motionone/utils/dist/defaults.es.js
var defaults;
var init_defaults_es = __esm({
  "node_modules/@motionone/utils/dist/defaults.es.js"() {
    defaults = {
      duration: 0.3,
      delay: 0,
      endDelay: 0,
      repeat: 0,
      easing: "ease"
    };
  }
});

// node_modules/@motionone/utils/dist/is-number.es.js
var isNumber;
var init_is_number_es = __esm({
  "node_modules/@motionone/utils/dist/is-number.es.js"() {
    isNumber = (value) => typeof value === "number";
  }
});

// node_modules/@motionone/utils/dist/is-easing-list.es.js
var isEasingList;
var init_is_easing_list_es = __esm({
  "node_modules/@motionone/utils/dist/is-easing-list.es.js"() {
    init_is_number_es();
    isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);
  }
});

// node_modules/@motionone/utils/dist/wrap.es.js
var wrap;
var init_wrap_es = __esm({
  "node_modules/@motionone/utils/dist/wrap.es.js"() {
    wrap = (min, max, v) => {
      const rangeSize = max - min;
      return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
    };
  }
});

// node_modules/@motionone/utils/dist/easing.es.js
function getEasingForSegment(easing, i) {
  return isEasingList(easing) ? easing[wrap(0, easing.length, i)] : easing;
}
var init_easing_es = __esm({
  "node_modules/@motionone/utils/dist/easing.es.js"() {
    init_is_easing_list_es();
    init_wrap_es();
  }
});

// node_modules/@motionone/utils/dist/mix.es.js
var mix;
var init_mix_es = __esm({
  "node_modules/@motionone/utils/dist/mix.es.js"() {
    mix = (min, max, progress2) => -progress2 * min + progress2 * max + min;
  }
});

// node_modules/@motionone/utils/dist/noop.es.js
var noop, noopReturn;
var init_noop_es = __esm({
  "node_modules/@motionone/utils/dist/noop.es.js"() {
    noop = () => {
    };
    noopReturn = (v) => v;
  }
});

// node_modules/@motionone/utils/dist/progress.es.js
var progress;
var init_progress_es = __esm({
  "node_modules/@motionone/utils/dist/progress.es.js"() {
    progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);
  }
});

// node_modules/@motionone/utils/dist/offset.es.js
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset.push(mix(min, 1, offsetProgress));
  }
}
function defaultOffset(length) {
  const offset = [0];
  fillOffset(offset, length - 1);
  return offset;
}
var init_offset_es = __esm({
  "node_modules/@motionone/utils/dist/offset.es.js"() {
    init_mix_es();
    init_progress_es();
  }
});

// node_modules/@motionone/utils/dist/interpolate.es.js
function interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {
  const length = output.length;
  const remainder = length - input.length;
  remainder > 0 && fillOffset(input, remainder);
  return (t) => {
    let i = 0;
    for (; i < length - 2; i++) {
      if (t < input[i + 1])
        break;
    }
    let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));
    const segmentEasing = getEasingForSegment(easing, i);
    progressInRange = segmentEasing(progressInRange);
    return mix(output[i], output[i + 1], progressInRange);
  };
}
var init_interpolate_es = __esm({
  "node_modules/@motionone/utils/dist/interpolate.es.js"() {
    init_mix_es();
    init_noop_es();
    init_offset_es();
    init_progress_es();
    init_easing_es();
    init_clamp_es();
  }
});

// node_modules/@motionone/utils/dist/is-cubic-bezier.es.js
var isCubicBezier;
var init_is_cubic_bezier_es = __esm({
  "node_modules/@motionone/utils/dist/is-cubic-bezier.es.js"() {
    init_is_number_es();
    isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);
  }
});

// node_modules/@motionone/utils/dist/is-easing-generator.es.js
var isEasingGenerator;
var init_is_easing_generator_es = __esm({
  "node_modules/@motionone/utils/dist/is-easing-generator.es.js"() {
    isEasingGenerator = (easing) => typeof easing === "object" && Boolean(easing.createAnimation);
  }
});

// node_modules/@motionone/utils/dist/is-string.es.js
var isString;
var init_is_string_es = __esm({
  "node_modules/@motionone/utils/dist/is-string.es.js"() {
    isString = (value) => typeof value === "string";
  }
});

// node_modules/@motionone/utils/dist/time.es.js
var time;
var init_time_es = __esm({
  "node_modules/@motionone/utils/dist/time.es.js"() {
    time = {
      ms: (seconds) => seconds * 1e3,
      s: (milliseconds) => milliseconds / 1e3
    };
  }
});

// node_modules/@motionone/utils/dist/velocity.es.js
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
var init_velocity_es = __esm({
  "node_modules/@motionone/utils/dist/velocity.es.js"() {
  }
});

// node_modules/@motionone/utils/dist/index.es.js
var init_index_es2 = __esm({
  "node_modules/@motionone/utils/dist/index.es.js"() {
    init_array_es();
    init_clamp_es();
    init_defaults_es();
    init_easing_es();
    init_interpolate_es();
    init_is_cubic_bezier_es();
    init_is_easing_generator_es();
    init_is_easing_list_es();
    init_is_function_es();
    init_is_number_es();
    init_is_string_es();
    init_mix_es();
    init_noop_es();
    init_offset_es();
    init_progress_es();
    init_time_es();
    init_velocity_es();
    init_wrap_es();
  }
});

// node_modules/@motionone/easing/dist/cubic-bezier.es.js
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noopReturn;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
var calcBezier, subdivisionPrecision, subdivisionMaxIterations;
var init_cubic_bezier_es = __esm({
  "node_modules/@motionone/easing/dist/cubic-bezier.es.js"() {
    init_index_es2();
    calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
    subdivisionPrecision = 1e-7;
    subdivisionMaxIterations = 12;
  }
});

// node_modules/@motionone/easing/dist/steps.es.js
var steps;
var init_steps_es = __esm({
  "node_modules/@motionone/easing/dist/steps.es.js"() {
    init_index_es2();
    steps = (steps2, direction = "end") => (progress2) => {
      progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
      const expanded = progress2 * steps2;
      const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
      return clamp(0, 1, rounded / steps2);
    };
  }
});

// node_modules/@motionone/easing/dist/index.es.js
var init_index_es3 = __esm({
  "node_modules/@motionone/easing/dist/index.es.js"() {
    init_cubic_bezier_es();
    init_steps_es();
  }
});

// node_modules/@motionone/animation/dist/utils/easing.es.js
function getEasingFunction(definition) {
  if (isFunction(definition))
    return definition;
  if (isCubicBezier(definition))
    return cubicBezier(...definition);
  const namedEasing = namedEasings[definition];
  if (namedEasing)
    return namedEasing;
  if (definition.startsWith("steps")) {
    const args = functionArgsRegex.exec(definition);
    if (args) {
      const argsArray = args[1].split(",");
      return steps(parseFloat(argsArray[0]), argsArray[1].trim());
    }
  }
  return noopReturn;
}
var namedEasings, functionArgsRegex;
var init_easing_es2 = __esm({
  "node_modules/@motionone/animation/dist/utils/easing.es.js"() {
    init_index_es3();
    init_index_es2();
    namedEasings = {
      ease: cubicBezier(0.25, 0.1, 0.25, 1),
      "ease-in": cubicBezier(0.42, 0, 1, 1),
      "ease-in-out": cubicBezier(0.42, 0, 0.58, 1),
      "ease-out": cubicBezier(0, 0, 0.58, 1)
    };
    functionArgsRegex = /\((.*?)\)/;
  }
});

// node_modules/@motionone/animation/dist/Animation.es.js
var Animation;
var init_Animation_es = __esm({
  "node_modules/@motionone/animation/dist/Animation.es.js"() {
    init_index_es2();
    init_easing_es2();
    Animation = class {
      constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = "normal", autoplay = true } = {}) {
        this.startTime = null;
        this.rate = 1;
        this.t = 0;
        this.cancelTimestamp = null;
        this.easing = noopReturn;
        this.duration = 0;
        this.totalDuration = 0;
        this.repeat = 0;
        this.playState = "idle";
        this.finished = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
        easing = easing || defaults.easing;
        if (isEasingGenerator(easing)) {
          const custom = easing.createAnimation(keyframes);
          easing = custom.easing;
          keyframes = custom.keyframes || keyframes;
          initialDuration = custom.duration || initialDuration;
        }
        this.repeat = repeat;
        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);
        this.updateDuration(initialDuration);
        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);
        this.tick = (timestamp) => {
          var _a;
          delay = delay;
          let t = 0;
          if (this.pauseTime !== void 0) {
            t = this.pauseTime;
          } else {
            t = (timestamp - this.startTime) * this.rate;
          }
          this.t = t;
          t /= 1e3;
          t = Math.max(t - delay, 0);
          if (this.playState === "finished" && this.pauseTime === void 0) {
            t = this.totalDuration;
          }
          const progress2 = t / this.duration;
          let currentIteration = Math.floor(progress2);
          let iterationProgress = progress2 % 1;
          if (!iterationProgress && progress2 >= 1) {
            iterationProgress = 1;
          }
          iterationProgress === 1 && currentIteration--;
          const iterationIsOdd = currentIteration % 2;
          if (direction === "reverse" || direction === "alternate" && iterationIsOdd || direction === "alternate-reverse" && !iterationIsOdd) {
            iterationProgress = 1 - iterationProgress;
          }
          const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);
          const latest = interpolate$1(this.easing(p));
          output(latest);
          const isAnimationFinished = this.pauseTime === void 0 && (this.playState === "finished" || t >= this.totalDuration + endDelay);
          if (isAnimationFinished) {
            this.playState = "finished";
            (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);
          } else if (this.playState !== "idle") {
            this.frameRequestId = requestAnimationFrame(this.tick);
          }
        };
        if (autoplay)
          this.play();
      }
      play() {
        const now = performance.now();
        this.playState = "running";
        if (this.pauseTime !== void 0) {
          this.startTime = now - this.pauseTime;
        } else if (!this.startTime) {
          this.startTime = now;
        }
        this.cancelTimestamp = this.startTime;
        this.pauseTime = void 0;
        this.frameRequestId = requestAnimationFrame(this.tick);
      }
      pause() {
        this.playState = "paused";
        this.pauseTime = this.t;
      }
      finish() {
        this.playState = "finished";
        this.tick(0);
      }
      stop() {
        var _a;
        this.playState = "idle";
        if (this.frameRequestId !== void 0) {
          cancelAnimationFrame(this.frameRequestId);
        }
        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);
      }
      cancel() {
        this.stop();
        this.tick(this.cancelTimestamp);
      }
      reverse() {
        this.rate *= -1;
      }
      commitStyles() {
      }
      updateDuration(duration) {
        this.duration = duration;
        this.totalDuration = duration * (this.repeat + 1);
      }
      get currentTime() {
        return this.t;
      }
      set currentTime(t) {
        if (this.pauseTime !== void 0 || this.rate === 0) {
          this.pauseTime = t;
        } else {
          this.startTime = performance.now() - t / this.rate;
        }
      }
      get playbackRate() {
        return this.rate;
      }
      set playbackRate(rate) {
        this.rate = rate;
      }
    };
  }
});

// node_modules/@motionone/animation/dist/index.es.js
var init_index_es4 = __esm({
  "node_modules/@motionone/animation/dist/index.es.js"() {
    init_Animation_es();
    init_easing_es2();
  }
});

// node_modules/hey-listen/dist/hey-listen.es.js
var hey_listen_es_exports = {};
__export(hey_listen_es_exports, {
  invariant: () => invariant,
  warning: () => warning
});
var warning, invariant;
var init_hey_listen_es = __esm({
  "node_modules/hey-listen/dist/hey-listen.es.js"() {
    warning = function() {
    };
    invariant = function() {
    };
    if (true) {
      warning = function(check, message) {
        if (!check && typeof console !== "undefined") {
          console.warn(message);
        }
      };
      invariant = function(check, message) {
        if (!check) {
          throw new Error(message);
        }
      };
    }
  }
});

// node_modules/@motionone/generators/dist/spring/defaults.es.js
var defaults2;
var init_defaults_es2 = __esm({
  "node_modules/@motionone/generators/dist/spring/defaults.es.js"() {
    defaults2 = {
      stiffness: 100,
      damping: 10,
      mass: 1
    };
  }
});

// node_modules/@motionone/generators/dist/spring/utils.es.js
var calcDampingRatio;
var init_utils_es = __esm({
  "node_modules/@motionone/generators/dist/spring/utils.es.js"() {
    init_defaults_es2();
    calcDampingRatio = (stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass) => damping / (2 * Math.sqrt(stiffness * mass));
  }
});

// node_modules/@motionone/generators/dist/utils/has-reached-target.es.js
function hasReachedTarget(origin, target, current) {
  return origin < target && current >= target || origin > target && current <= target;
}
var init_has_reached_target_es = __esm({
  "node_modules/@motionone/generators/dist/utils/has-reached-target.es.js"() {
  }
});

// node_modules/@motionone/generators/dist/utils/velocity.es.js
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - sampleT, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}
var sampleT;
var init_velocity_es2 = __esm({
  "node_modules/@motionone/generators/dist/utils/velocity.es.js"() {
    init_index_es2();
    sampleT = 5;
  }
});

// node_modules/@motionone/generators/dist/spring/index.es.js
var spring;
var init_index_es5 = __esm({
  "node_modules/@motionone/generators/dist/spring/index.es.js"() {
    init_index_es2();
    init_defaults_es2();
    init_utils_es();
    init_has_reached_target_es();
    init_velocity_es2();
    spring = ({ stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass, from = 0, to = 1, velocity = 0, restSpeed, restDistance } = {}) => {
      velocity = velocity ? time.s(velocity) : 0;
      const state = {
        done: false,
        hasReachedTarget: false,
        current: from,
        target: to
      };
      const initialDelta = to - from;
      const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
      const dampingRatio = calcDampingRatio(stiffness, damping, mass);
      const isGranularScale = Math.abs(initialDelta) < 5;
      restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
      restDistance || (restDistance = isGranularScale ? 5e-3 : 0.5);
      let resolveSpring;
      if (dampingRatio < 1) {
        const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
        resolveSpring = (t) => to - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((-velocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      } else {
        resolveSpring = (t) => {
          return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t);
        };
      }
      return (t) => {
        state.current = resolveSpring(t);
        const currentVelocity = t === 0 ? velocity : calcGeneratorVelocity(resolveSpring, t, state.current);
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        state.hasReachedTarget = hasReachedTarget(from, to, state.current);
        return state;
      };
    };
  }
});

// node_modules/@motionone/generators/dist/glide/index.es.js
var glide;
var init_index_es6 = __esm({
  "node_modules/@motionone/generators/dist/glide/index.es.js"() {
    init_index_es2();
    init_velocity_es2();
    init_index_es5();
    glide = ({ from = 0, velocity = 0, power = 0.8, decay = 0.325, bounceDamping, bounceStiffness, changeTarget, min, max, restDistance = 0.5, restSpeed }) => {
      decay = time.ms(decay);
      const state = {
        hasReachedTarget: false,
        done: false,
        current: from,
        target: from
      };
      const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
      const nearestBoundary = (v) => {
        if (min === void 0)
          return max;
        if (max === void 0)
          return min;
        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
      };
      let amplitude = power * velocity;
      const ideal = from + amplitude;
      const target = changeTarget === void 0 ? ideal : changeTarget(ideal);
      state.target = target;
      if (target !== ideal)
        amplitude = target - from;
      const calcDelta = (t) => -amplitude * Math.exp(-t / decay);
      const calcLatest = (t) => target + calcDelta(t);
      const applyFriction = (t) => {
        const delta = calcDelta(t);
        const latest = calcLatest(t);
        state.done = Math.abs(delta) <= restDistance;
        state.current = state.done ? target : latest;
      };
      let timeReachedBoundary;
      let spring$1;
      const checkCatchBoundary = (t) => {
        if (!isOutOfBounds(state.current))
          return;
        timeReachedBoundary = t;
        spring$1 = spring({
          from: state.current,
          to: nearestBoundary(state.current),
          velocity: calcGeneratorVelocity(calcLatest, t, state.current),
          // TODO: This should be passing * 1000
          damping: bounceDamping,
          stiffness: bounceStiffness,
          restDistance,
          restSpeed
        });
      };
      checkCatchBoundary(0);
      return (t) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t);
          checkCatchBoundary(t);
        }
        if (timeReachedBoundary !== void 0 && t > timeReachedBoundary) {
          state.hasReachedTarget = true;
          return spring$1(t - timeReachedBoundary);
        } else {
          state.hasReachedTarget = false;
          !hasUpdatedFrame && applyFriction(t);
          return state;
        }
      };
    };
  }
});

// node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js
function pregenerateKeyframes(generator, toUnit = noopReturn) {
  let overshootDuration = void 0;
  let timestamp = timeStep;
  let state = generator(0);
  const keyframes = [toUnit(state.current)];
  while (!state.done && timestamp < maxDuration) {
    state = generator(timestamp);
    keyframes.push(toUnit(state.done ? state.target : state.current));
    if (overshootDuration === void 0 && state.hasReachedTarget) {
      overshootDuration = timestamp;
    }
    timestamp += timeStep;
  }
  const duration = timestamp - timeStep;
  if (keyframes.length === 1)
    keyframes.push(state.current);
  return {
    keyframes,
    duration: duration / 1e3,
    overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1e3
  };
}
var timeStep, maxDuration;
var init_pregenerate_keyframes_es = __esm({
  "node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js"() {
    init_index_es2();
    timeStep = 10;
    maxDuration = 1e4;
  }
});

// node_modules/@motionone/generators/dist/index.es.js
var init_index_es7 = __esm({
  "node_modules/@motionone/generators/dist/index.es.js"() {
    init_index_es6();
    init_index_es5();
    init_pregenerate_keyframes_es();
    init_velocity_es2();
  }
});

export {
  invariant,
  hey_listen_es_exports,
  init_hey_listen_es,
  MotionValue,
  init_index_es,
  addUniqueItem,
  removeItem,
  defaults,
  isNumber,
  isEasingList,
  getEasingForSegment,
  mix,
  noop,
  noopReturn,
  progress,
  fillOffset,
  defaultOffset,
  interpolate,
  isCubicBezier,
  isEasingGenerator,
  isFunction,
  isString,
  time,
  velocityPerSecond,
  init_index_es2,
  getEasingFunction,
  Animation,
  init_index_es4 as init_index_es3,
  calcGeneratorVelocity,
  spring,
  glide,
  pregenerateKeyframes,
  init_index_es7 as init_index_es4
};
//# sourceMappingURL=chunk-V56GQFIG.js.map
