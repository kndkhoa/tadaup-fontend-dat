{
  "version": 3,
  "sources": ["../../@motionone/types/dist/MotionValue.es.js", "../../@motionone/types/dist/index.es.js", "../../@motionone/utils/dist/is-function.es.js", "../../@motionone/utils/dist/array.es.js", "../../@motionone/utils/dist/clamp.es.js", "../../@motionone/utils/dist/defaults.es.js", "../../@motionone/utils/dist/is-number.es.js", "../../@motionone/utils/dist/is-easing-list.es.js", "../../@motionone/utils/dist/wrap.es.js", "../../@motionone/utils/dist/easing.es.js", "../../@motionone/utils/dist/mix.es.js", "../../@motionone/utils/dist/noop.es.js", "../../@motionone/utils/dist/progress.es.js", "../../@motionone/utils/dist/offset.es.js", "../../@motionone/utils/dist/interpolate.es.js", "../../@motionone/utils/dist/is-cubic-bezier.es.js", "../../@motionone/utils/dist/is-easing-generator.es.js", "../../@motionone/utils/dist/is-string.es.js", "../../@motionone/utils/dist/time.es.js", "../../@motionone/utils/dist/velocity.es.js", "../../@motionone/utils/dist/index.es.js", "../../@motionone/easing/dist/cubic-bezier.es.js", "../../@motionone/easing/dist/steps.es.js", "../../@motionone/easing/dist/index.es.js", "../../@motionone/animation/dist/utils/easing.es.js", "../../@motionone/animation/dist/Animation.es.js", "../../@motionone/animation/dist/index.es.js", "../../hey-listen/dist/hey-listen.es.js", "../../@motionone/generators/dist/spring/defaults.es.js", "../../@motionone/generators/dist/spring/utils.es.js", "../../@motionone/generators/dist/utils/has-reached-target.es.js", "../../@motionone/generators/dist/utils/velocity.es.js", "../../@motionone/generators/dist/spring/index.es.js", "../../@motionone/generators/dist/glide/index.es.js", "../../@motionone/generators/dist/utils/pregenerate-keyframes.es.js", "../../@motionone/generators/dist/index.es.js"],
  "sourcesContent": ["/**\n * The MotionValue tracks the state of a single animatable\n * value. Currently, updatedAt and current are unused. The\n * long term idea is to use this to minimise the number\n * of DOM reads, and to abstract the DOM interactions here.\n */\nclass MotionValue {\n    setAnimation(animation) {\n        this.animation = animation;\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\n    }\n    clearAnimation() {\n        this.animation = this.generator = undefined;\n    }\n}\n\nexport { MotionValue };\n", "export { MotionValue } from './MotionValue.es.js';\n", "const isFunction = (value) => typeof value === \"function\";\n\nexport { isFunction };\n", "function addUniqueItem(array, item) {\n    array.indexOf(item) === -1 && array.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n", "const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n", "const defaults = {\n    duration: 0.3,\n    delay: 0,\n    endDelay: 0,\n    repeat: 0,\n    easing: \"ease\",\n};\n\nexport { defaults };\n", "const isNumber = (value) => typeof value === \"number\";\n\nexport { isNumber };\n", "import { isNumber } from './is-number.es.js';\n\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\nexport { isEasingList };\n", "const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n", "import { isEasingList } from './is-easing-list.es.js';\nimport { wrap } from './wrap.es.js';\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nexport { getEasingForSegment };\n", "const mix = (min, max, progress) => -progress * min + progress * max + min;\n\nexport { mix };\n", "const noop = () => { };\nconst noopReturn = (v) => v;\n\nexport { noop, noopReturn };\n", "const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nexport { progress };\n", "import { mix } from './mix.es.js';\nimport { progress } from './progress.es.js';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\nexport { defaultOffset, fillOffset };\n", "import { mix } from './mix.es.js';\nimport { noopReturn } from './noop.es.js';\nimport { fillOffset, defaultOffset } from './offset.es.js';\nimport { progress } from './progress.es.js';\nimport { getEasingForSegment } from './easing.es.js';\nimport { clamp } from './clamp.es.js';\n\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n", "import { isNumber } from './is-number.es.js';\n\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\n\nexport { isCubicBezier };\n", "const isEasingGenerator = (easing) => typeof easing === \"object\" &&\n    Boolean(easing.createAnimation);\n\nexport { isEasingGenerator };\n", "const isString = (value) => typeof value === \"string\";\n\nexport { isString };\n", "const time = {\n    ms: (seconds) => seconds * 1000,\n    s: (milliseconds) => milliseconds / 1000,\n};\n\nexport { time };\n", "/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n", "export { addUniqueItem, removeItem } from './array.es.js';\nexport { clamp } from './clamp.es.js';\nexport { defaults } from './defaults.es.js';\nexport { getEasingForSegment } from './easing.es.js';\nexport { interpolate } from './interpolate.es.js';\nexport { isCubicBezier } from './is-cubic-bezier.es.js';\nexport { isEasingGenerator } from './is-easing-generator.es.js';\nexport { isEasingList } from './is-easing-list.es.js';\nexport { isFunction } from './is-function.es.js';\nexport { isNumber } from './is-number.es.js';\nexport { isString } from './is-string.es.js';\nexport { mix } from './mix.es.js';\nexport { noop, noopReturn } from './noop.es.js';\nexport { defaultOffset, fillOffset } from './offset.es.js';\nexport { progress } from './progress.es.js';\nexport { time } from './time.es.js';\nexport { velocityPerSecond } from './velocity.es.js';\nexport { wrap } from './wrap.es.js';\n", "import { noopReturn } from '@motionone/utils';\n\n/*\n  Bezier function generator\n\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n", "import { clamp } from '@motionone/utils';\n\nconst steps = (steps, direction = \"end\") => (progress) => {\n    progress =\n        direction === \"end\"\n            ? Math.min(progress, 0.999)\n            : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexport { steps };\n", "export { cubicBezier } from './cubic-bezier.es.js';\nexport { steps } from './steps.es.js';\n", "import { cubicBezier, steps } from '@motionone/easing';\nimport { isFunction, isCubicBezier, noopReturn } from '@motionone/utils';\n\nconst namedEasings = {\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\n};\nconst functionArgsRegex = /\\((.*?)\\)/;\nfunction getEasingFunction(definition) {\n    // If already an easing function, return\n    if (isFunction(definition))\n        return definition;\n    // If an easing curve definition, return bezier function\n    if (isCubicBezier(definition))\n        return cubicBezier(...definition);\n    // If we have a predefined easing function, return\n    const namedEasing = namedEasings[definition];\n    if (namedEasing)\n        return namedEasing;\n    // If this is a steps function, attempt to create easing curve\n    if (definition.startsWith(\"steps\")) {\n        const args = functionArgsRegex.exec(definition);\n        if (args) {\n            const argsArray = args[1].split(\",\");\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\n        }\n    }\n    return noopReturn;\n}\n\nexport { getEasingFunction };\n", "import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\n\nclass Animation {\n    constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", autoplay = true, } = {}) {\n        this.startTime = null;\n        this.rate = 1;\n        this.t = 0;\n        this.cancelTimestamp = null;\n        this.easing = noopReturn;\n        this.duration = 0;\n        this.totalDuration = 0;\n        this.repeat = 0;\n        this.playState = \"idle\";\n        this.finished = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        easing = easing || defaults.easing;\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            initialDuration = custom.duration || initialDuration;\n        }\n        this.repeat = repeat;\n        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\n        this.updateDuration(initialDuration);\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\n        this.tick = (timestamp) => {\n            var _a;\n            // TODO: Temporary fix for OptionsResolver typing\n            delay = delay;\n            let t = 0;\n            if (this.pauseTime !== undefined) {\n                t = this.pauseTime;\n            }\n            else {\n                t = (timestamp - this.startTime) * this.rate;\n            }\n            this.t = t;\n            // Convert to seconds\n            t /= 1000;\n            // Rebase on delay\n            t = Math.max(t - delay, 0);\n            /**\n             * If this animation has finished, set the current time\n             * to the total duration.\n             */\n            if (this.playState === \"finished\" && this.pauseTime === undefined) {\n                t = this.totalDuration;\n            }\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = t / this.duration;\n            // TODO progress += iterationStart\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (direction === \"reverse\" ||\n                (direction === \"alternate\" && iterationIsOdd) ||\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\n                iterationProgress = 1 - iterationProgress;\n            }\n            const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\n            const latest = interpolate$1(this.easing(p));\n            output(latest);\n            const isAnimationFinished = this.pauseTime === undefined &&\n                (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\n            if (isAnimationFinished) {\n                this.playState = \"finished\";\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n            }\n            else if (this.playState !== \"idle\") {\n                this.frameRequestId = requestAnimationFrame(this.tick);\n            }\n        };\n        if (autoplay)\n            this.play();\n    }\n    play() {\n        const now = performance.now();\n        this.playState = \"running\";\n        if (this.pauseTime !== undefined) {\n            this.startTime = now - this.pauseTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = now;\n        }\n        this.cancelTimestamp = this.startTime;\n        this.pauseTime = undefined;\n        this.frameRequestId = requestAnimationFrame(this.tick);\n    }\n    pause() {\n        this.playState = \"paused\";\n        this.pauseTime = this.t;\n    }\n    finish() {\n        this.playState = \"finished\";\n        this.tick(0);\n    }\n    stop() {\n        var _a;\n        this.playState = \"idle\";\n        if (this.frameRequestId !== undefined) {\n            cancelAnimationFrame(this.frameRequestId);\n        }\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    }\n    cancel() {\n        this.stop();\n        this.tick(this.cancelTimestamp);\n    }\n    reverse() {\n        this.rate *= -1;\n    }\n    commitStyles() { }\n    updateDuration(duration) {\n        this.duration = duration;\n        this.totalDuration = duration * (this.repeat + 1);\n    }\n    get currentTime() {\n        return this.t;\n    }\n    set currentTime(t) {\n        if (this.pauseTime !== undefined || this.rate === 0) {\n            this.pauseTime = t;\n        }\n        else {\n            this.startTime = performance.now() - t / this.rate;\n        }\n    }\n    get playbackRate() {\n        return this.rate;\n    }\n    set playbackRate(rate) {\n        this.rate = rate;\n    }\n}\n\nexport { Animation };\n", "export { Animation } from './Animation.es.js';\nexport { getEasingFunction } from './utils/easing.es.js';\n", "var warning = function () { };\r\nvar invariant = function () { };\r\nif (process.env.NODE_ENV !== 'production') {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\n\nexport { invariant, warning };\n", "const defaults = {\n    stiffness: 100.0,\n    damping: 10.0,\n    mass: 1.0,\n};\n\nexport { defaults };\n", "import { defaults } from './defaults.es.js';\n\nconst calcDampingRatio = (stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass) => damping / (2 * Math.sqrt(stiffness * mass));\n\nexport { calcDampingRatio };\n", "function hasReachedTarget(origin, target, current) {\n    return ((origin < target && current >= target) ||\n        (origin > target && current <= target));\n}\n\nexport { hasReachedTarget };\n", "import { velocityPerSecond } from '@motionone/utils';\n\nconst sampleT = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - sampleT, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n", "import { time } from '@motionone/utils';\nimport { defaults } from './defaults.es.js';\nimport { calcDampingRatio } from './utils.es.js';\nimport { hasReachedTarget } from '../utils/has-reached-target.es.js';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\n\nconst spring = ({ stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass, from = 0, to = 1, velocity = 0.0, restSpeed, restDistance, } = {}) => {\n    velocity = velocity ? time.s(velocity) : 0.0;\n    const state = {\n        done: false,\n        hasReachedTarget: false,\n        current: from,\n        target: to,\n    };\n    const initialDelta = to - from;\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    const dampingRatio = calcDampingRatio(stiffness, damping, mass);\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDistance || (restDistance = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n        // Underdamped spring (bouncy)\n        resolveSpring = (t) => to -\n            Math.exp(-dampingRatio * undampedAngularFreq * t) *\n                (((-velocity + dampingRatio * undampedAngularFreq * initialDelta) /\n                    angularFreq) *\n                    Math.sin(angularFreq * t) +\n                    initialDelta * Math.cos(angularFreq * t));\n    }\n    else {\n        // Critically damped spring\n        resolveSpring = (t) => {\n            return (to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t));\n        };\n    }\n    return (t) => {\n        state.current = resolveSpring(t);\n        const currentVelocity = t === 0\n            ? velocity\n            : calcGeneratorVelocity(resolveSpring, t, state.current);\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n        state.hasReachedTarget = hasReachedTarget(from, to, state.current);\n        return state;\n    };\n};\n\nexport { spring };\n", "import { time } from '@motionone/utils';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\nimport { spring } from '../spring/index.es.js';\n\nconst glide = ({ from = 0, velocity = 0.0, power = 0.8, decay = 0.325, bounceDamping, bounceStiffness, changeTarget, min, max, restDistance = 0.5, restSpeed, }) => {\n    decay = time.ms(decay);\n    const state = {\n        hasReachedTarget: false,\n        done: false,\n        current: from,\n        target: from,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = changeTarget === undefined ? ideal : changeTarget(ideal);\n    state.target = target;\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - from;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / decay);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDistance;\n        state.current = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.current))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            from: state.current,\n            to: nearestBoundary(state.current),\n            velocity: calcGeneratorVelocity(calcLatest, t, state.current), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDistance,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return (t) => {\n        /**\n         * We need to resolve the friction to figure out if we need a\n         * spring but we don't want to do this twice per frame. So here\n         * we flag if we updated for this frame and later if we did\n         * we can skip doing it again.\n         */\n        let hasUpdatedFrame = false;\n        if (!spring$1 && timeReachedBoundary === undefined) {\n            hasUpdatedFrame = true;\n            applyFriction(t);\n            checkCatchBoundary(t);\n        }\n        /**\n         * If we have a spring and the provided t is beyond the moment the friction\n         * animation crossed the min/max boundary, use the spring.\n         */\n        if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n            state.hasReachedTarget = true;\n            return spring$1(t - timeReachedBoundary);\n        }\n        else {\n            state.hasReachedTarget = false;\n            !hasUpdatedFrame && applyFriction(t);\n            return state;\n        }\n    };\n};\n\nexport { glide };\n", "import { noopReturn } from '@motionone/utils';\n\nconst timeStep = 10;\nconst maxDuration = 10000;\nfunction pregenerateKeyframes(generator, toUnit = noopReturn) {\n    let overshootDuration = undefined;\n    let timestamp = timeStep;\n    let state = generator(0);\n    const keyframes = [toUnit(state.current)];\n    while (!state.done && timestamp < maxDuration) {\n        state = generator(timestamp);\n        keyframes.push(toUnit(state.done ? state.target : state.current));\n        if (overshootDuration === undefined && state.hasReachedTarget) {\n            overshootDuration = timestamp;\n        }\n        timestamp += timeStep;\n    }\n    const duration = timestamp - timeStep;\n    /**\n     * If generating an animation that didn't actually move,\n     * generate a second keyframe so we have an origin and target.\n     */\n    if (keyframes.length === 1)\n        keyframes.push(state.current);\n    return {\n        keyframes,\n        duration: duration / 1000,\n        overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1000,\n    };\n}\n\nexport { pregenerateKeyframes };\n", "export { glide } from './glide/index.es.js';\nexport { spring } from './spring/index.es.js';\nexport { pregenerateKeyframes } from './utils/pregenerate-keyframes.es.js';\nexport { calcGeneratorVelocity } from './utils/velocity.es.js';\n"],
  "mappings": "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",
  "names": ["progress", "init_index_es", "init_index_es", "init_index_es", "steps", "progress", "init_index_es", "init_easing_es", "init_index_es", "init_index_es", "init_easing_es", "progress", "init_index_es", "init_easing_es", "defaults", "init_defaults_es", "init_defaults_es", "defaults", "init_velocity_es", "init_index_es", "init_index_es", "init_defaults_es", "init_velocity_es", "defaults", "init_index_es", "init_velocity_es", "init_index_es", "init_index_es", "init_velocity_es"]
}
